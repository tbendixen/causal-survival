---
title: "Causal survival analysis in R"
author: "Theiss Bendixen"
format:
  html:
    number-sections: TRUE
    toc: TRUE
number-depth: 2
editor: source
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      results='hide', 
                      cache=TRUE, 
                      warning = FALSE,
                      message = FALSE,
                      error = TRUE,
                      cache.comments = FALSE,
                      cache.lazy = FALSE)

```

# Introduction

In this notebook, we demonstrate various flavors of non-, semi- and parametric survival analysis from a causal, potential outcomes approach in `R`. We mostly follow Hernan & Robins (2020).

Specifically, we'll cover:

-   G-computation with logistic polynomial regression 
-   G-computation with Cox proportional hazards model [NB: needs bootstrapping]
-   Inverse probability of treatment weighting in logistic regression
-   Inverse probability of treatment weighting in Cox proportional hazards model [NB: needs bootstrapping]
-   Inverse probability of treatment weighting in Kaplan-Meier
-   Sub-group analysis with g-computation and logistic polynomial regression [NB: needs bootstrapping]
-   Sub-group analysis with IP weighted Kaplan-Meier

The dataset is `nhefs` containing data from the National Health and Nutrition Examination Survey Data I Epidemiologic Follow-up Study.

# Set-up

```{r set-up, cache = FALSE}
library(readxl)
library(ggplot2)
library(tidybayes)
library(boot)
library(dplyr)
library(splitstackshape)
library(survival)
library(survminer)
library(ggplot2)

nhefs <- read_excel("NHEFS.xls")
```

# Data wrangling: From wide to long

```{r dat-prep, cache=FALSE, dependson="set-up"}
# 120 months, because the follow-up period was ten years (10yrs*12 months)
# yrdth ranges from 83 to 92
nhefs$survtime <- ifelse(nhefs$death==0, 120,
                         (nhefs$yrdth-83)*12+nhefs$modth)


nhefs.surv <- expandRows(nhefs, "survtime", drop=F) 
nhefs.surv$time <- sequence(rle(nhefs.surv$seqn)$lengths)-1
nhefs.surv$event <- ifelse(nhefs.surv$time==nhefs.surv$survtime-1 & 
                             nhefs.surv$death==1, 1, 0)
nhefs.surv$timesq <- nhefs.surv$time^2

# set id column
nhefs.surv$id <- nhefs.surv$seqn

# set number of iterations to bootstrap (high values are computationally intensive)
n_R <- 1e3
```

# G-computation

## Logistic regression

```{r g-comp-logit, dependson="dat-prep"}
gcomp_logistic <- function(formula, sample, data, indices) {
  
  # length of final follow-up in sample
  tmax <- max(data$time, na.rm=T) + 1
  
  # bootstrap individuals
  id <- unique(data$id)
  random_id <- sample(id, length(id), replace = TRUE)
  d <- data |>
    filter(id %in% random_id)
  
  # covariate-adjusted logistic regression
  mod <- glm(formula, family=binomial(), data=d)
  
  # creation of dataset with all time points for 
  # each individual under each treatment level.
  # predictions are obtained for the full sample,
  # i.e. post-stratification to the sample of interest.
  qsmk0 <- expandRows(sample, count=tmax, count.is.col=F) 
  qsmk0$time <- rep(seq(0, tmax-1), nrow(sample))
  qsmk0$timesq <- qsmk0$time^2
  qsmk0$qsmk <- 0
  
  qsmk1 <- qsmk0
  qsmk1$qsmk <- 1
  
  # predicted probabilities
  qsmk0$p.noevent0 <- predict(mod, qsmk0, type="response")
  qsmk1$p.noevent1 <- predict(mod, qsmk1, type="response")

  # computation of survival for each person-month
  qsmk0.surv <- qsmk0 |> group_by(seqn) |> mutate(surv0 = cumprod(p.noevent0))
  qsmk1.surv <- qsmk1 |> group_by(seqn) |> mutate(surv1 = cumprod(p.noevent1))
  
  # marginalize
  surv0 <-
    aggregate(qsmk0.surv,
              by = list(qsmk0.surv$time),
              FUN = mean)[c("qsmk", "time", "surv0")]
  surv1 <-
    aggregate(qsmk1.surv,
              by = list(qsmk1.surv$time),
              FUN = mean)[c("qsmk", "time", "surv1")]
  
  return(c(surv0$surv0, surv1$surv1))
}

# g-comp bootstrap
(bootstrapped_results <- boot(data=nhefs.surv,
                              sample = nhefs,
                              statistic=gcomp_logistic,
                              R=n_R, 
                              formula=event==0 ~ qsmk + I(qsmk*time) + I(qsmk*timesq)
                              + time + timesq + sex + race + age + I(age*age)
                              + as.factor(education) + smokeintensity 
                              + I(smokeintensity*smokeintensity) + smkintensity82_71 
                              + smokeyrs + I(smokeyrs*smokeyrs) + as.factor(exercise) 
                              + as.factor(active) + wt71 + I(wt71*wt71)))

# data wrangle for plotting
tmin <- min(nhefs.surv$time, na.rm=T)
tmax <- max(nhefs.surv$time, na.rm=T)

# collect results in data frame
boot_samples <- with(
  bootstrapped_results,
  data.frame(
  time = rep(tmin:tmax, each=R),
  surv0 = c(t[,(tmin+1):(tmax+1)]),
  surv1 = c(t[,(tmax+2):(tmax*2+2)]),
  draw = rep(1:R, each=tmax+1))
  )

```

```{r g-comp-logit-plot, dependson="g-comp-log", fig.align = 'center', fig.width=8, fig.asp=0.618}
# survival curves
survival_plot <- ggplot(boot_samples, aes(x=time, y=surv)) + 
  stat_lineribbon(aes(y = surv0, colour = "0"), fill = "grey", alpha = 0.5, .width=.95) +
  stat_lineribbon(aes(y = surv1, colour = "1"), fill = "grey", alpha = 0.5, .width=.95) +
  xlab("Months of follow-up") + 
  scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
  scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2)) +
  ylab("Survival") + 
  ggtitle("Logistic polynomial model (g-computation)") + 
  labs(colour="A:") +
  theme_classic() + 
  theme(legend.position="bottom")

# contrast survival curve
boot_samples$survdiff <- with(boot_samples,
                              surv1 - surv0)

contrast_plot <- 
  ggplot(boot_samples, aes(x=time, y=(survdiff)*100)) + 
  stat_lineribbon(fill = "grey", alpha = 0.5, .width=.95) +
  scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,20)) +
  xlab("Months of follow-up") + 
  ylab("Difference in %") + 
  ggtitle("Percentage difference\nin survival") + 
  labs(colour="A:") +
  theme_classic() + 
  theme(legend.position="bottom")

# Add the second plot as an annotation to the first plot
survival_plot + annotation_custom(grob = ggplotGrob(contrast_plot), 
                                           xmin = 0, xmax = 60, 
                                           ymin = 0.6, ymax = 0.8)

```

## Cox regression

```{r gcomp-cox, dependson="dat-prep"}
# set event and id columns
nhefs$event <- nhefs$death
nhefs$id <- nhefs$seqn

# Cox model
mod <- coxph(Surv(survtime, event) ~ qsmk + sex + race + age + age:age
                              + as.factor(education) + smokeintensity 
                              + smokeintensity:smokeintensity + smkintensity82_71 
                              + smokeyrs + smokeyrs:smokeyrs + as.factor(exercise) 
                              + as.factor(active) + wt71 + wt71:wt71, data = nhefs)

# creation of datasets with all observed time points for 
# each individual under each treatment level.
qsmk0 <- transform(nhefs, qsmk = 0)
qsmk1 <- transform(nhefs, qsmk = 1)

# predicted time to event under each treatment
fit_qsmk0 <- survfit(mod, newdata = qsmk0)
surv0 <- fit_qsmk0$surv |> as.data.frame()
surv0 <- surv0 |> tidyr::pivot_longer(cols = everything(), 
                                      names_to = "id",
                                      values_to = "surv")
surv0$time <- rep(fit_qsmk0$time, each = length(unique(surv0$id)))
surv0$qsmk <- 0

fit_qsmk1 <- survfit(mod, newdata = qsmk1)
surv1 <- fit_qsmk1$surv |> as.data.frame()
surv1 <- surv1 |> tidyr::pivot_longer(cols = everything(), 
                                      names_to = "id",
                                      values_to = "surv")
surv1$time <- rep(fit_qsmk1$time, each = length(unique(surv1$id)))
surv1$qsmk <- 1

# marginalize
surv0 <- 
  aggregate(surv ~ time + qsmk,
            data = surv0,
            FUN = mean)

surv1 <- 
  aggregate(surv ~ time + qsmk,
            data = surv1,
            FUN = mean)

# collect in dataframe
cox_surv <- data.frame(
  time = surv0$time,
  surv0 = surv0$surv,
  surv1 = surv1$surv
)

```

```{r gcomp-cox-plot, dependson="gcomp-cox", fig.align = 'center', fig.width=8, fig.asp=0.618}
ggplot(cox_surv, aes(x=time, y=surv)) + 
  geom_line(aes(y = surv0, colour = "1")) + 
  geom_line(aes(y = surv1, colour = "2")) + 
  scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
  scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2)) +
  xlab("Months") + 
  ylab("Survival") + 
  ggtitle("Cox proportional hazards model (g-computation)") + 
  labs(colour="A:") +
  theme_bw() + 
  theme(legend.position="bottom")

```

# Inverse probability of treatment weighting

## Logistic regression

```{r iptw-logit, dependson="dat-prep"}
# set event and id columns
nhefs$event <- nhefs$death
nhefs$id <- nhefs$seqn

iptw_logistic <- function(formula, data, indices) {
  
  # length of final follow-up in sample
  tmax <- max(data$survtime, na.rm=T)
  
  # bootstrap individuals
  id <- unique(data$id)
  random_id <- sample(id, length(id), replace = TRUE)
  d <- data |>
    filter(id %in% random_id)

  # estimation of denominator of ip weights
  p.denom <- glm(formula, family=binomial(), data=d)
  d$pd.qsmk <- predict(p.denom, d, type="response")

  # estimation of numerator of ip weights
  p.num <- glm(qsmk ~ 1, data=d, family=binomial())
  d$pn.qsmk <- predict(p.num, d, type="response")
  
  # computation of estimated weights
  d$sw.a <- ifelse(d$qsmk==1, d$pn.qsmk/d$pd.qsmk,
                       (1-d$pn.qsmk)/(1-d$pd.qsmk))
  
  # creation of person-month data
  d.iptw <- expandRows(d, "survtime", drop=F) 
  d.iptw$time <- sequence(rle(d.iptw$id)$lengths)-1
  d.iptw$event <- ifelse(d.iptw$time==d.iptw$survtime-1 & 
                            d.iptw$event==1, 1, 0)
  d.iptw$timesq <- d.iptw$time^2
  
  # fit weighted polynomial logistic model
  ipw.model <- glm(event==0 ~ qsmk + I(qsmk*time) + I(qsmk*timesq) + 
                    time + timesq, family=binomial(), weight=sw.a,
                  data=d.iptw)

  # creation of survival curves
  ipw.qsmk0 <- data.frame(cbind(seq(0, tmax-1),0,(seq(0, tmax-1))^2))
  ipw.qsmk1 <- data.frame(cbind(seq(0, tmax-1),1,(seq(0, tmax-1))^2))

  colnames(ipw.qsmk0) <- c("time", "qsmk", "timesq")
  colnames(ipw.qsmk1) <- c("time", "qsmk", "timesq")

  # assignment of estimated (1-hazard) to each person-month */
  ipw.qsmk0$p.noevent0 <- predict(ipw.model, ipw.qsmk0, type="response")
  ipw.qsmk1$p.noevent1 <- predict(ipw.model, ipw.qsmk1, type="response")
  
  # computation of survival for each person-month
  ipw.qsmk0$surv0 <- cumprod(ipw.qsmk0$p.noevent0)
  ipw.qsmk1$surv1 <- cumprod(ipw.qsmk1$p.noevent1)
  
  return(c(ipw.qsmk0$surv0, ipw.qsmk1$surv1))
}

# iptw bootstrap
(bootstrapped_results <- boot(data=nhefs,
                              statistic=iptw_logistic,
                              R=n_R,
                              formula=qsmk ~ sex + race + age + I(age*age) + as.factor(education)
                              + smokeintensity + I(smokeintensity*smokeintensity)
                              + smokeyrs + I(smokeyrs*smokeyrs) + as.factor(exercise)
                              + as.factor(active) + wt71 + I(wt71*wt71)))

# data wrangle for plotting
tmin <- min(nhefs.surv$time, na.rm=T)
tmax <- max(nhefs.surv$time, na.rm=T)

# collect results in data frame
boot_samples <- with(
  bootstrapped_results,
  data.frame(
  time = rep(tmin:tmax, each=R),
  surv0 = c(t[,(tmin+1):(tmax+1)]),
  surv1 = c(t[,(tmax+2):(tmax*2+2)]),
  draw = rep(1:R, each=tmax+1))
  )

```

```{r iptw-logit-plot, dependson="iptw-logit", fig.width=8, fig.asp=0.618}
# plot
(survival_plot <- ggplot(boot_samples, aes(x=time, y=surv)) + 
  stat_lineribbon(aes(y = surv0, colour = "0"), fill = "grey", alpha = 0.5, .width=.95) +
  stat_lineribbon(aes(y = surv1, colour = "1"), fill = "grey", alpha = 0.5, .width=.95) +
  xlab("Months of follow-up") + 
  scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
  scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2)) +
  ylab("Survival") + 
  ggtitle("Logistic polynomial model (IPTW)") + 
  labs(colour="A:") +
  theme_bw() + 
  theme(legend.position="bottom"))
```

## Cox regression

NB: This gives a slightly different result from the other approaches -- namely, that there's no notable difference between `qsmk = 1` and `qsmk = 0` when balancing the groups with IP weights.

I've tried to debug the code but without success. We can check that the post-processing code is working as intended by deleting the `weights` argument from the Cox model; then, we see a clear difference between the two groups.

This could indicate that, when the hazard is constrained to be proportional, we find little evidence of a difference between the two groups. This would be sort of consistent with the IP weighted Kaplan-Meier below.

```{r iptw-cox}
nhefs$event <- nhefs$death
nhefs$id <- nhefs$seqn

d <- nhefs

# estimation of denominator of ip weights
p.denom <- glm(qsmk ~ sex + race + age + I(age*age) + as.factor(education)
               + smokeintensity + I(smokeintensity*smokeintensity)
               + smokeyrs + I(smokeyrs*smokeyrs) + as.factor(exercise)
               + as.factor(active) + wt71 + I(wt71*wt71), family=binomial(), data=d)
d$pd.qsmk <- predict(p.denom, d, type="response")

# estimation of numerator of ip weights
p.num <- glm(qsmk ~ 1, data=d, family=binomial())
d$pn.qsmk <- predict(p.num, d, type="response")

# computation of estimated weights
d$sw.a <- ifelse(d$qsmk==1, d$pn.qsmk/d$pd.qsmk,
                 (1-d$pn.qsmk)/(1-d$pd.qsmk))

# fit of weighted Cox model
mod <- coxph(Surv(survtime, event) ~ qsmk, weights = d$sw.a, data = d)

# wrangle for plotting
ipw.qsmk0 <- data.frame(qsmk=c(0))
ipw.qsmk1 <- data.frame(qsmk=c(1))

iptw_fit_qsmk0 <- survfit(mod, newdata = ipw.qsmk0)
iptw_fit_qsmk1 <- survfit(mod, newdata = ipw.qsmk1)

iptw_surv <- data.frame(time = iptw_fit_qsmk0$time,
                        surv0 = iptw_fit_qsmk0$surv,
                        surv0_l = iptw_fit_qsmk0$lower,
                        surv0_u = iptw_fit_qsmk0$upper,
                        surv1 = iptw_fit_qsmk1$surv,
                        surv1_l = iptw_fit_qsmk1$lower,
                        surv1_u = iptw_fit_qsmk1$upper)
```

```{r iptw-cox-plot, dependson="iptw-cox", fig.width=8, fig.asp=0.618}
# plot
(survival_plot <- ggplot(iptw_surv, aes(x=time, y=surv)) + 
    geom_line(aes(y = surv0, colour = "1")) + 
    geom_line(aes(y = surv1, colour = "2")) + 
    xlab("Months of follow-up") + 
    scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
    scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2)) +
    ylab("Survival") + 
    ggtitle("Cox proportional hazards model (IPTW)") + 
    labs(colour="A:") +
    theme_bw() + 
    theme(legend.position="bottom"))

```

# Kaplan-Meier

## Unadjusted

```{r unadj-kaplan-meier, fig.width=8, fig.asp=0.618}
# no weights
npfit <- survfit(Surv(survtime, event) ~ qsmk, data=nhefs)

# create plot
npplot <- ggsurvplot(npfit, data = nhefs, xlab="Months of follow-up",
           ylab="Survival probability",
           main="Product-Limit Survival Estimates", conf.int = TRUE) 

# extract plot
npplot$plot + scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
           scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2))  + 
           theme(legend.position="bottom") + 
           ggtitle("Kaplan-Meier (unadjusted)")
```

## IP weighted

```{r ip-kaplan-meier, fig.width=8, fig.asp=0.618}
# we re-use weights from earlier
npfit <- survfit(Surv(survtime, event) ~ qsmk, weights = d$sw.a, data=d)

# create plot
npplot <- ggsurvplot(npfit, data = nhefs, xlab="Months of follow-up",
           ylab="Survival probability",
           main="Product-Limit Survival Estimates", conf.int = TRUE) 

# extract plot
npplot$plot + scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
           scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2))  + 
           theme(legend.position="bottom") + 
           ggtitle("Kaplan-Meier (IPTW)")
```

# Sub-group analysis

## G-computation

Let's say we're interested in assessing whether the effect of `qsmk` differs by sex.

```{r sub-gcomp}
# set-up data frame -- easier for converting to bootstrapping later
d <- nhefs.surv
sample <- nhefs

tmax <- max(d$time, na.rm=T) + 1

# covariate-adjusted logistic regression
# only new thing is that we include an interaction term for qsmk*sex
mod <- glm(event==0 ~ qsmk + I(qsmk*sex) + I(qsmk*time) + I(qsmk*timesq)
           + time + timesq + sex + race + age + I(age*age)
           + as.factor(education) + smokeintensity 
           + I(smokeintensity*smokeintensity) + smkintensity82_71 
           + smokeyrs + I(smokeyrs*smokeyrs) + as.factor(exercise) 
           + as.factor(active) + wt71 + I(wt71*wt71), 
           family=binomial(), data=d)

# creation of dataset with all time points for 
# each individual under each treatment level.
# predictions are obtained for the full sample,
# i.e. post-stratification to the sample of interest.
qsmk0 <- expandRows(sample, count=tmax, count.is.col=F) 
qsmk0$time <- rep(seq(0, tmax-1), nrow(sample))
qsmk0$timesq <- qsmk0$time^2

qsmk1 <- qsmk0
qsmk1$qsmk <- 1

# qsmk = 0, sex = 0
q0s0 <- qsmk0
q0s0$sex <- 0

# qsmk = 0, sex = 1
q0s1 <- qsmk0
q0s1$sex <- 1

# qsmk = 1, sex = 0
q1s0 <- qsmk1
q1s0$sex <- 0

# qsmk = 1, sex = 1
q1s1 <- qsmk1
q1s1$sex <- 1

# predicted probabilities for each strata and condition
q0s0$p.noevent0 <- predict(mod, q0s0, type="response")
q0s1$p.noevent0 <- predict(mod, q0s1, type="response")
q1s0$p.noevent0 <- predict(mod, q1s0, type="response")
q1s1$p.noevent0 <- predict(mod, q1s1, type="response")

# computation of survival for each person-month
q0s0.surv <- q0s0 |> group_by(seqn) |> mutate(surv = cumprod(p.noevent0))
q0s1.surv <- q0s1 |> group_by(seqn) |> mutate(surv = cumprod(p.noevent0))
q1s0.surv <- q1s0 |> group_by(seqn) |> mutate(surv = cumprod(p.noevent0))
q1s1.surv <- q1s1 |> group_by(seqn) |> mutate(surv = cumprod(p.noevent0))

# marginalize
surv00 <-
  aggregate(q0s0.surv,
            by = list(q0s0.surv$time),
            FUN = mean)[c("qsmk", "time", "surv")]
surv01 <-
  aggregate(q0s1.surv,
            by = list(q0s1.surv$time),
            FUN = mean)[c("qsmk", "time", "surv")]

surv10 <-
  aggregate(q1s0.surv,
            by = list(q1s0.surv$time),
            FUN = mean)[c("qsmk", "time", "surv")]
surv11 <-
  aggregate(q1s1.surv,
            by = list(q1s1.surv$time),
            FUN = mean)[c("qsmk", "time", "surv")]

# data wrangle for plotting
subgroup_surv <- data.frame(
  time = surv00$time,
  surv00 = surv00$surv,
  surv01 = surv01$surv,
  surv10 = surv10$surv,
  surv11 = surv11$surv
)

```

```{r sub-gcomp-plot, dependson="sub-gcomp", fig.width=8, fig.asp=0.618}
ggplot(subgroup_surv, aes(x=time, y=surv)) + 
  geom_line(aes(y = surv00, colour = "1")) + 
  geom_line(aes(y = surv01, colour = "2")) + 
  geom_line(aes(y = surv10, colour = "3")) + 
  geom_line(aes(y = surv11, colour = "4")) +
  scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
  scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2)) +
  xlab("Months") + 
  ylab("Survival") + 
  ggtitle("Subgroup logistic polynomial model (g-computation)") + 
  labs(colour="A:") +
  scale_color_hue(labels = c("qsmk=0, sex=0", "qsmk=0, sex=1",
                             "qsmk=1, sex=0", "qsmk=1, sex=1")) +
  theme_bw() + 
  theme(legend.position="bottom")

```

## Kaplan-Meier

Let's compare our g-computation results with IP weighted Kaplan-Meier. Now, for subgroup analysis with IPTW, there are a few subtleties. Hernan and Robins (2020:165-166) write:

>Marginal structural models do not include covariates when the target parameter is the average causal effect in the population. However, one may include covariates --- which may be non-confounders --- in a marginal structural model to assess effect modification. the effect estimates. In most settings, the vector of covariates $L$ should include $V$. Even when $V$ and $A$ are independent given the other components of $L$ and $V$ is not needed to ensure exchangeability, including $V$ in $L$ will generally increase the efficiency with which the parameters of the marginal structural model are estimated.

They continue:

>Because we are considering a model for the effect of treatment within levels of $V$, we now have the choice to use either $f[A]$ or $f[A|V]$ in the numerator of the stabilized weights. IP weighting based on the stabilized weights $SW^A(V) = \frac{f[A|V]} {f[A|L]}$ generally results in narrower confidence intervals around the effect estimates. Some intuition for the generally increased statistical efficiency of $SW^A (V)$ is that the variance of the weights $SW^A(V)$ is less than that of the weights $SW^A$. We estimate $SW^A (V)$ using the same approach as for $SW^A$, except that we add the covariate $V$ to the logistic model for the numerator of the weights.

We'll try both approaches -- they give identical results in our case, perhaps due to the non-parametric nature of the Kaplan-Meier estimator?

### Stabilized weights without $V$

```{r sub-kaplan-meier, fig.width=8, fig.asp=0.618}
# we re-use weights from earlier
nhefs$event <- nhefs$death
nhefs$id <- nhefs$seqn

d <- nhefs

# estimation of denominator of ip weights -- nothing new here
p.denom <- glm(qsmk ~ as.factor(sex) + race + age + I(age*age) + as.factor(education)
               + smokeintensity + I(smokeintensity*smokeintensity)
               + smokeyrs + I(smokeyrs*smokeyrs) + as.factor(exercise)
               + as.factor(active) + wt71 + I(wt71*wt71), family=binomial(), data=d)
d$pd.qsmk <- predict(p.denom, d, type="response")

# estimation of numerator of ip weights -- nothing new here
p.num <- glm(qsmk ~ 1, data=d, family=binomial())
d$pn.qsmk <- predict(p.num, d, type="response")

# computation of estimated weights
d$sw.a <- ifelse(d$qsmk==1, d$pn.qsmk/d$pd.qsmk,
                 (1-d$pn.qsmk)/(1-d$pd.qsmk))

# only new thing is that we add sex to the weighted model
npfit <- survfit(Surv(survtime, event) ~ qsmk + as.factor(sex) + I(qsmk*sex), weights = d$sw.a, data=d)

# create plot
npplot <- ggsurvplot(npfit, data = nhefs, xlab="Months of follow-up",
           ylab="Survival probability",
           main="Product-Limit Survival Estimates", conf.int = TRUE) 

# extract plot
npplot$plot + scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
           scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2))  + 
           theme(legend.position="bottom") + 
           ggtitle("Subgroup Kaplan-Meier (IPTW without V)")

```

### Stabilized weights with $V$

```{r sub-kaplan-meier-wL, fig.width=8, fig.asp=0.618}
# we compute new weights
nhefs$event <- nhefs$death
nhefs$id <- nhefs$seqn

d <- nhefs

# estimation of denominator of ip weights
p.denom <- glm(qsmk ~ as.factor(sex) + race + age + I(age*age) + as.factor(education)
               + smokeintensity + I(smokeintensity*smokeintensity)
               + smokeyrs + I(smokeyrs*smokeyrs) + as.factor(exercise)
               + as.factor(active) + wt71 + I(wt71*wt71), family=binomial(), data=d)
d$pd.qsmk <- predict(p.denom, d, type="response")

# estimation of numerator of ip weights
# new thing is that we add sex to the numerator model
p.num <- glm(qsmk ~ as.factor(sex), data=d, family=binomial())
d$pn.qsmk <- predict(p.num, d, type="response")

# computation of estimated weights
d$sw.aV <- ifelse(d$qsmk==1, d$pn.qsmk/d$pd.qsmk,
                 (1-d$pn.qsmk)/(1-d$pd.qsmk))

# IP weighted Kaplan-Meier
npfit_V <- survfit(Surv(survtime, event) ~ qsmk + sex + I(qsmk*sex), weights = d$sw.aV, data=d)

# create plot
npVplot <- ggsurvplot(npfit_V, data = nhefs, xlab="Months of follow-up",
           ylab="Survival probability",
           main="Product-Limit Survival Estimates", conf.int = TRUE) 

# extract plot
npVplot$plot + scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
           scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2))  + 
           theme(legend.position="bottom") + 
           ggtitle("Subgroup Kaplan-Meier (IPTW with V)")

```

## Cox regression

We can also run IP weighted subgroup analysis with Cox regression to assess whether this yields another result than the Kaplan-Meier estimate. As it turns out, in these data and models, it appears to make no difference whether we use $SW^A$ or $SW^A (V)$. 

### Stabilized weights without $V$

```{r subgroup-cox-sw}
nhefs$event <- nhefs$death
nhefs$id <- nhefs$seqn

d <- nhefs

# estimation of denominator of ip weights
p.denom <- glm(qsmk ~ sex + race + age + I(age*age) + as.factor(education)
               + smokeintensity + I(smokeintensity*smokeintensity)
               + smokeyrs + I(smokeyrs*smokeyrs) + as.factor(exercise)
               + as.factor(active) + wt71 + I(wt71*wt71), family=binomial(), data=d)
d$pd.qsmk <- predict(p.denom, d, type="response")

# estimation of numerator of ip weights
p.num <- glm(qsmk ~ 1, data=d, family=binomial())
d$pn.qsmk <- predict(p.num, d, type="response")

# computation of estimated weights
d$sw.a <- ifelse(d$qsmk==1, d$pn.qsmk/d$pd.qsmk,
                 (1-d$pn.qsmk)/(1-d$pd.qsmk))

# fit of weighted Cox model
mod <- coxph(Surv(survtime, event) ~ qsmk*sex, weights = d$sw.a, data = d)

# wrangle for plotting
ipw.qsmk00 <- data.frame(qsmk=0,sex=0)
ipw.qsmk01 <- data.frame(qsmk=0,sex=1)
ipw.qsmk10 <- data.frame(qsmk=1,sex=0)
ipw.qsmk11 <- data.frame(qsmk=1,sex=1)

iptw_fit_qsmk00 <- survfit(mod, newdata = ipw.qsmk00)
iptw_fit_qsmk01 <- survfit(mod, newdata = ipw.qsmk01)
iptw_fit_qsmk10 <- survfit(mod, newdata = ipw.qsmk10)
iptw_fit_qsmk11 <- survfit(mod, newdata = ipw.qsmk11)

subgroup_iptw_surv <- data.frame(time = iptw_fit_qsmk00$time,
                        surv00 = iptw_fit_qsmk00$surv,
                        surv01 = iptw_fit_qsmk01$surv,
                        surv10 = iptw_fit_qsmk10$surv,
                        surv11 = iptw_fit_qsmk11$surv)
```

```{r subgroup-cox-sw-plot, dependson="subgroup-cox-sw"}
ggplot(subgroup_iptw_surv, aes(x=time, y=surv)) + 
  geom_line(aes(y = surv00, colour = "1")) + 
  geom_line(aes(y = surv01, colour = "2")) + 
  geom_line(aes(y = surv10, colour = "3")) + 
  geom_line(aes(y = surv11, colour = "4")) +
  scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
  scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2)) +
  xlab("Months") + 
  ylab("Survival") + 
  ggtitle("Subgroup Cox proportional hazards model (IPTW without V)") + 
  labs(colour="A:") +
  scale_color_hue(labels = c("qsmk=0, sex=0", "qsmk=0, sex=1",
                             "qsmk=1, sex=0", "qsmk=1, sex=1")) +
  theme_bw() + 
  theme(legend.position="bottom")
```

### Stabilized weights with $V$

```{r subgroup-cox-swv}
nhefs$event <- nhefs$death
nhefs$id <- nhefs$seqn

d <- nhefs

# estimation of denominator of ip weights
p.denom <- glm(qsmk ~ sex + race + age + I(age*age) + as.factor(education)
               + smokeintensity + I(smokeintensity*smokeintensity)
               + smokeyrs + I(smokeyrs*smokeyrs) + as.factor(exercise)
               + as.factor(active) + wt71 + I(wt71*wt71), family=binomial(), data=d)
d$pd.qsmk <- predict(p.denom, d, type="response")

# estimation of numerator of ip weights
p.num <- glm(qsmk ~ 1, data=d, family=binomial())
d$pn.qsmk <- predict(p.num, d, type="response")

# computation of estimated weights
d$sw.aV <- ifelse(d$qsmk==1, d$pn.qsmk/d$pd.qsmk,
                 (1-d$pn.qsmk)/(1-d$pd.qsmk))

# fit of weighted Cox model
mod <- coxph(Surv(survtime, event) ~ qsmk*sex, weights = d$sw.aV, data = d)

# wrangle for plotting
ipw.qsmk00 <- data.frame(qsmk=0,sex=0)
ipw.qsmk01 <- data.frame(qsmk=0,sex=1)
ipw.qsmk10 <- data.frame(qsmk=1,sex=0)
ipw.qsmk11 <- data.frame(qsmk=1,sex=1)

iptw_fit_qsmk00 <- survfit(mod, newdata = ipw.qsmk00)
iptw_fit_qsmk01 <- survfit(mod, newdata = ipw.qsmk01)
iptw_fit_qsmk10 <- survfit(mod, newdata = ipw.qsmk10)
iptw_fit_qsmk11 <- survfit(mod, newdata = ipw.qsmk11)

subgroup_iptw_surv <- data.frame(time = iptw_fit_qsmk00$time,
                        surv00 = iptw_fit_qsmk00$surv,
                        surv01 = iptw_fit_qsmk01$surv,
                        surv10 = iptw_fit_qsmk10$surv,
                        surv11 = iptw_fit_qsmk11$surv)
```

```{r subgroup-cox-swV-plot, dependson="subgroup-cox-swv"}
ggplot(subgroup_iptw_surv, aes(x=time, y=surv)) + 
  geom_line(aes(y = surv00, colour = "1")) + 
  geom_line(aes(y = surv01, colour = "2")) + 
  geom_line(aes(y = surv10, colour = "3")) + 
  geom_line(aes(y = surv11, colour = "4")) +
  scale_x_continuous(limits = c(0, 120), breaks=seq(0,120,12)) +
  scale_y_continuous(limits=c(0.6, 1), breaks=seq(0.6, 1, 0.2)) +
  xlab("Months") + 
  ylab("Survival") + 
  ggtitle("Subgroup Cox proportional hazards model (IPTW with V)") + 
  labs(colour="A:") +
  scale_color_hue(labels = c("qsmk=0, sex=0", "qsmk=0, sex=1",
                             "qsmk=1, sex=0", "qsmk=1, sex=1")) +
  theme_bw() + 
  theme(legend.position="bottom")
```
